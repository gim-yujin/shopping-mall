# Shopping Mall 프로젝트 최적화 기법 종합 분석

이 문서는 코드/스키마를 직접 점검하여, **대규모 트래픽**과 **동시성 문제** 대응 관점에서 실제 적용된 최적화 기법을 정리한 결과다.

---

## 1) 캐싱 전략 (핫 경로 읽기 부하 분산)

### 1-1. Caffeine 로컬 캐시 도입
- `@EnableCaching` + `CaffeineCacheManager`를 통해 홈/상품/검색/리뷰/카테고리/쿠폰 등 조회성 엔드포인트를 폭넓게 캐시한다.
- `expireAfterWrite(5분)` + `maximumSize(100)` + `recordStats()` 조합으로, 무한 증가를 막고 히트율 계측까지 가능하게 했다.
- 효과: DB read QPS 감소, p95 응답시간 안정화, 스파이크 시 방어력 향상.

### 1-2. 홈 화면 다중 섹션 캐싱
- 홈은 베스트셀러/신상품/딜/인기검색어/카테고리를 한 번에 로드하는 집약 페이지다.
- 각 섹션 데이터가 분리 캐시되어, 홈 트래픽 집중 시에도 동일 쿼리 재실행을 최소화한다.
- 효과: 홈 페이지의 "N개 블록 × N번 DB 조회"를 캐시 hit 기반으로 흡수.

### 1-3. 상품 상세 캐시 + 조회수 쓰기 비동기 분리
- 상품 상세 조회(`productDetail`)를 캐시하고, 조회수 증가는 비동기 executor로 분리한다.
- 즉, 요청 스레드는 읽기 중심으로 빠르게 반환하고, 쓰기는 별도 처리.
- 효과: hot 상품 상세에서 read/write 경합 완화, 커넥션 점유시간 단축.

### 1-4. 캐시 관측성(Observability)
- 30초 주기로 캐시별 hit/miss/size를 로그화한다.
- 효과: "캐시가 실제로 성능 개선에 기여하는지"를 운영 중 수치로 검증 가능.

---

## 2) 동시성 제어 전략 (정합성 + 처리량 균형)

### 2-1. 비관적 락(PESSIMISTIC_WRITE)로 재고/쿠폰/취소 직렬화
- `ProductRepository.findByIdWithLock`, `CouponRepository.findBy...WithLock`, `OrderRepository.findByIdAndUserIdWithLock` 등에서 비관적 락을 사용한다.
- 재고 차감/복구, 쿠폰 발급 수량 소진, 이중 취소 같은 경쟁 구간에서 "먼저 잡은 트랜잭션 우선"으로 직렬화한다.
- 효과: overselling, double cancel, 한정 쿠폰 초과 발급 리스크를 DB 락 레벨에서 차단.

### 2-2. Advisory Lock으로 사용자 장바구니 직렬화
- `pg_advisory_xact_lock(userId)`로 동일 사용자의 동시 장바구니 변경을 순차 처리한다.
- row lock이 아닌 key-based transaction lock을 사용해, 사용자 단위 직렬화라는 도메인 요구를 정확히 반영.
- 효과: 장바구니 수량 꼬임/중복 삽입 race 완화.

### 2-3. ON CONFLICT DO NOTHING 기반 멱등 토글
- 위시리스트/리뷰 도움 토글은 native SQL `INSERT ... ON CONFLICT DO NOTHING` + delete row-count 패턴을 쓴다.
- 동시 요청에서도 중복키 예외 폭발 없이 멱등하게 상태를 수렴시킨다.
- 효과: 고동시성 토글에서 예외/재시도 비용 감소.

### 2-4. UNIQUE 제약 + 예외 변환으로 중복 발급 방어
- `uk_user_coupon_user_coupon`, `uk_wishlist_user_product`, `uk_helpful_review_user` 등 도메인 중복을 DB 제약으로 강제한다.
- 서비스 계층에서는 `DataIntegrityViolationException`을 비즈니스 예외로 매핑해 사용자 경험을 유지.
- 효과: 애플리케이션 버그나 race가 있어도 최종 정합성은 DB가 보장.

### 2-5. 데드락 예방: 락 획득 순서 통일
- 주문 생성/취소 시 상품을 productId 오름차순으로 정렬 후 락 획득한다.
- 효과: 트랜잭션마다 락 순서가 달라 발생하는 교착 가능성 감소.

### 2-6. EntityManager.refresh로 락 이후 최신 상태 재검증
- 비관적 락 이후 `entityManager.refresh()`로 1차 캐시에 남은 stale state를 DB 최신값으로 동기화한다.
- 효과: stale read 기반 계산 오류(재고/쿠폰 수량 판단 오차) 방지.

---

## 3) DB 접근/쿼리 최적화

### 3-1. 페이징(Pageable) 광범위 적용
- 상품/주문/리뷰/쿠폰/위시리스트/카테고리/관리자 화면에 페이지네이션을 기본 사용.
- 효과: full scan 결과를 한 번에 메모리에 적재하는 패턴 방지, 응답/메모리 사용량 예측 가능.

### 3-2. JOIN FETCH로 N+1 완화
- 장바구니/유저쿠폰/위시리스트/상품상세(카테고리 포함) 등에서 연관 엔티티를 한 번에 가져온다.
- 효과: 템플릿 렌더링 중 지연 로딩으로 인한 추가 쿼리 폭증 감소.

### 3-3. OSIV 비활성화 + 트랜잭션 내부 초기화
- `open-in-view: false`로 웹 응답 단계까지 커넥션이 오래 잡히지 않게 했다.
- 필요한 지연 컬렉션은 서비스 트랜잭션 안에서 미리 초기화한다.
- 효과: 커넥션 풀 점유 시간 단축, 고부하에서 pool starvation 완화.

### 3-4. Hibernate batch 튜닝
- `default_batch_fetch_size=100`, `jdbc.batch_size=50`, `order_inserts/updates=true`를 설정.
- 효과: 다건 연관 조회/쓰기 시 round-trip 감소, flush 효율 개선.

### 3-5. PostgreSQL 전문 검색(FTS) + fallback
- `to_tsvector @@ plainto_tsquery`를 우선 사용하고, 결과 없을 때 LIKE 검색으로 fallback.
- `idx_product_name_gin`으로 FTS 성능을 받쳐준다.
- 효과: 검색 정확도/성능 균형 + 무결과 상황 UX 보완.

---

## 4) 인덱스 설계 (트래픽 패턴 반영)

> 아래는 코드/스키마에서 확인되는 핵심 인덱스와 목적 요약이다.

### 4-1. 상품/검색 경로
- `idx_product_name_gin` (GIN FTS): 키워드 검색 가속
- `idx_product_category (category_id, is_active, sales_count DESC)`: 카테고리 목록 + 정렬 대응
- `idx_product_sales`, `idx_product_created`, `idx_product_rating`, `idx_product_price_active`: 홈/목록 정렬별 대응
- `idx_product_deals ((original_price - price) DESC) WHERE ...`: 특가 정렬용 함수/부분 인덱스

### 4-2. 주문/주문아이템 경로
- `idx_order_user (user_id, order_date DESC)`: 마이페이지 주문목록
- `idx_order_status (order_status, order_date)`: 관리자 상태 필터
- `idx_order_items_covering (order_id, product_id) INCLUDE (quantity, subtotal)`: order_items 조회 시 커버링 인덱스

### 4-3. 리뷰/도움/위시/장바구니 경로
- `idx_review_product (product_id, created_at DESC)`, `idx_review_rating`
- `idx_review_content_gin` (리뷰 본문 검색 대비)
- `idx_wishlist_user`, `idx_cart_user`: 사용자별 최신순 조회
- `idx_review_helpful_review`, `idx_review_helpful_user`: 토글/집계 조회

### 4-4. 쿠폰/유저쿠폰/로그 경로
- `idx_coupon_valid (valid_from, valid_until, is_active)`: 활성 쿠폰 필터
- `idx_user_coupon_user (user_id, is_used, expires_at)`: 사용가능 쿠폰 조회
- `idx_search_keyword (search_keyword, searched_at DESC)`: 인기 검색어 집계 보조

### 4-5. 무결성 기반 동시성 제어 인덱스(UNIQUE)
- `uk_cart_user_product`, `uk_wishlist_user_product`, `uk_helpful_review_user`, `uk_user_coupon_user_coupon`, `uk_review_user_order_item`
- 목적: 중복 상태를 애플리케이션 로직이 아닌 DB 제약으로 최종 차단.

---

## 5) 스레드/커넥션/응답 경로 최적화

### 5-1. HikariCP 풀 크기 고정
- `maximum-pool-size = minimum-idle = 17`로 fixed-size pool 운영.
- 주석에 명시된 대로 `(코어*2)+1` 공식을 따르며, 과도한 풀 팽창/축소를 피한다.
- `connection-timeout=5s`로 대기 장기화를 막아 빠르게 실패시킨다.
- 효과: 트래픽 급증 시 tail latency 악화를 제한하고 장애 전파를 줄임.

### 5-2. 비동기 executor 분리
- 별도 `ThreadPoolTaskExecutor(core4/max8/queue500)`를 두고, 검색로그/조회수 같은 지연 허용 쓰기를 오프로딩.
- 효과: 사용자 요청 스레드는 핵심 비즈니스 응답에 집중.

### 5-3. 서버 압축 및 템플릿 캐시
- HTTP compression 활성화 + Thymeleaf cache 활성화.
- 효과: 네트워크 전송량/SSR 재파싱 비용 절감.

### 5-4. 로깅 레벨 하향
- SQL/바인딩 로그를 WARN 수준으로 낮춰 I/O 오버헤드 축소.
- 효과: 부하 테스트/운영에서 로그 병목 완화.

---

## 6) 템플릿 렌더링 최적화

### 6-1. 페이지네이션 윈도우 렌더링
- `fragments/product-card.html`의 pagination fragment는 전체 페이지를 순회하지 않고, `현재 페이지 ±2` 범위만 렌더링한다.
- 효과: 총 페이지 수가 큰 경우 템플릿 계산/DOM 출력량 감소.
- 질문 예시로 주신 "전체 스캔 대신 윈도우 범위" 최적화가 실제 적용되어 있다.

### 6-2. 화면 단 분할(fragment 재사용)
- 홈 카드 렌더링을 fragment insert로 재사용해 중복 템플릿 비용/유지보수 비용을 줄였다.

---

## 7) 이 프로젝트의 최적화 설계가 주는 통찰

1. **정합성은 DB 제약/락에서 보장하고, 성능은 캐시/비동기로 보완**하는 2중 전략을 택했다.
2. **핫 리드 경로(홈/목록/상세/검색)는 캐시 + 인덱스 + 페이징**으로 방어하고,
3. **핫 라이트 경로(주문/쿠폰/토글/장바구니)는 락 순서/UNIQUE/ON CONFLICT**로 경쟁상황을 제어한다.
4. 단순히 "빠르게"가 아니라, **경쟁 조건에서도 결과가 일관되게 수렴**하도록 설계된 점이 핵심이다.

---

## 8) 개선 여지(추가 제안)

- 도메인별 TTL 분리를 적용했으므로, 다음 단계는 캐시 히트율 기반으로 TTL을 재튜닝(A/B)하는 것이다.
- `@Cacheable` key에 sort 파라미터 누락 가능성이 없는지 점검(일부 home cache는 고정 key) 필요.
- 인기검색어 집계는 트래픽이 더 커지면 materialized view / 배치 집계 테이블로 이전 고려.
- 분산 환경(멀티 인스턴스)으로 확대되면 로컬 캐시(Caffeine)만으로는 일관성 한계가 있으므로 Redis 계층 검토.



## 9) 도메인별 캐시 TTL 분리안 (적용)

기존 단일 TTL(5분)에서 도메인별 TTL로 분리했다.

- **홈 집계(`bestSellers`, `newArrivals`, `deals`, `topCategories`, `popularKeywords`) = 1분**
  - 이유: 트래픽 집중 구간이지만 초 단위 정합성이 필수는 아닌 집계성 데이터다. 1분만으로도 홈 DB 조회를 크게 줄이면서 신선도 저하를 제한한다.
- **카테고리 계층(`subCategories`, `categoryDescendants`, `categoryBreadcrumb`, `categoryById`) = 30분**
  - 이유: 변경 빈도가 낮은 준-정적 데이터다. 긴 TTL이 가장 큰 이득(쿼리 감축)을 제공한다.
- **상품 목록/검색(`productList`, `searchResults`, `categoryProducts`) = 2분**
  - 이유: 조회량이 높고 목록 정렬/검색 결과가 자주 요청되지만 가격/재고 반영 지연을 길게 가져가면 UX 저하가 커진다. 2분은 성능-신선도 절충값이다.
- **상품 상세(`productDetail`) = 2분**
  - 이유: hot product 상세 read를 흡수해야 하며, 조회수는 비동기로 반영되어도 무방하다. 다만 가격/재고 stale 리스크 때문에 5분보다 짧게 유지한다.
- **리뷰 목록(`productReviews`) = 30초**
  - 이유: 작성/삭제/도움 토글로 변동이 빈번하고 사용자 체감 민감도가 높다. stale 허용치를 낮춰 짧은 TTL을 선택한다.
- **인증 사용자(`userDetails`) = 1분**
  - 이유: 권한/계정상태 변경 전파가 너무 느리면 보안/운영 리스크가 생긴다. 매우 짧은 TTL로 안전성을 우선한다.
- **활성 쿠폰(`activeCoupons`) = 10초**
  - 이유: 유효기간 경계, 프로모션 활성/비활성, 선착순 소진 등 시간 민감도가 가장 높은 도메인이다. 짧은 TTL이 맞다.
